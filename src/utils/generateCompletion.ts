export const generateCompletion = (name: string): string => {
    return `### Generated by @kearisp/cli ###

if type compdef &>/dev/null; then
    _${name}_completion() {
        compadd -- \`${name} complete --compzsh --compgen "\${CURRENT}" "\${words[CURRENT - 1]}" \${BUFFER}\`
    }

    compdef _${name}_completion ${name}
elif type complete &>/dev/null; then
    _${name}_completion() {
        local cur prev nb_colon
        _get_comp_words_by_ref -n : cur prev
        nb_colon=$(grep -o ":" <<< "$COMP_LINE" | wc -l)

        local OPTIONS=$(${name} complete --compbash --compgen "$((COMP_CWORD - (nb_colon * 2)))" "$prev" "\${COMP_LINE}")

        COMPREPLY=()
        STR=$(compgen -W "\${OPTIONS}" -- "$cur")

        while IFS= read -r line; do
            if [[ $cur != \\'* && $cur != \\"* ]]; then
                line=$(echo \${line} | sed 's/ /\\\\ /g')
            else
                line="\\"$line\\""
            fi

            COMPREPLY+=("$line")
        done <<< "$STR"

        __ltrim_colon_completions "$cur"
    }

    complete -F _${name}_completion ${name}
elif type compctl &>/dev/null; then
    _${name}_completion () {
        local cword line point si
        read -Ac words
        read -cn cword
        read -l line
        si="$IFS"
        if ! IFS=$'\n' reply=($(${name} complete --compzsh --compgen "\${cword}" "\${words[cword - 1]}" \${line})); then
            local ret=$?
            IFS="$si"
            return $ret
        fi
        IFS="$si"
    }

    compctl -K _${name}_completion ${name}
fi`;
};
