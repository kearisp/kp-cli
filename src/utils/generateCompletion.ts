export const generateCompletion = (name: string): string => {
    return `### Generated by @kearisp/cli ###

if type compdef &>/dev/null; then
    _${name}_completion() {
        compadd -- \`${name} complete --compzsh --compgen "\${CURRENT}" \${BUFFER}\`
    }

    compdef _${name}_completion ${name}
elif type complete &>/dev/null; then
    _${name}_completion() {
        local cur prev nb_colon
        _get_comp_words_by_ref -n : cur prev
        nb_colon=$(grep -o ":" <<< "$COMP_LINE" | wc -l)

        local OPTIONS=$(${name} complete --compbash --compgen "$((COMP_CWORD - (nb_colon * 2)))" "\${COMP_LINE}")

        COMPREPLY=()

        if [[ $OPTIONS = '__WOCKER_DIR_AND_FILE_PATH__' ]]; then
            local files_and_dirs=($(compgen -f -d -- "$cur"))

            for path in "\${files_and_dirs[@]}"; do
                if [[ -d "$path" ]]; then
                    COMPREPLY+=("\${path}/")
                else
                    COMPREPLY+=("$path")
                fi
            done

            compopt -o nospace
        else
            STR=$(compgen -W "\${OPTIONS}" -- "$cur")

            while IFS= read -r line; do
                if [[ $cur != \\'* && $cur != \\"* ]]; then
                    line=$(echo \${line} | sed 's/ /\\\\ /g')
                else
                    line="\\"$line\\""
                fi

                COMPREPLY+=("$line")
            done <<< "$STR"
        fi

        __ltrim_colon_completions "$cur"
    }

    complete -F _${name}_completion ${name}
elif type compctl &>/dev/null; then
    _${name}_completion () {
        local cword line point si
        read -Ac words
        read -cn cword
        read -l line
        si="$IFS"
        if ! IFS=$'\n' reply=($(${name} complete --compzsh --compgen "\${cword}" \${line})); then
            local ret=$?
            IFS="$si"
            return $ret
        fi
        IFS="$si"
    }

    compctl -K _${name}_completion ${name}
fi`;
};
