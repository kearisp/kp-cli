export const generateCompletion = (name: string) => {
    return `### Generated by @kp/cli ###

if type compdef &>/dev/null; then
    _${name}_completion() {
        compadd -- \`${name} --compzsh --compgen "\${CURRENT}" "\${words[CURRENT - 1]}" \${BUFFER}\`
    }

    compdef _${name}_completion ${name}
elif type complete &>/dev/null; then
    _${name}_completion() {
        local cur prev nb_colon
        _get_comp_words_by_ref -n : cur prev
        nb_colon=$(grep -o ":" <<< "$COMP_LINE" | wc -l)

        local OPTIONS=$(${name} --compbash --compgen "$((COMP_CWORD - (nb_colon * 2)))" "$prev" "\${COMP_LINE}")

        COMPREPLY=$(compgen -W "\${OPTIONS}" -- "$cur")

        mapfile -t COMPREPLY <<< "$COMPREPLY"

        for (( i=0; i<\${#COMPREPLY[@]}; i++ )); do
            if [[ "\${COMPREPLY[$i]}" == *' '* ]]; then
                COMPREPLY[$i]="\${COMPREPLY[$i]}\"
            else
                COMPREPLY[$i]=\${COMPREPLY[$i]//\\/\\\\}
            fi
        done

        __ltrim_colon_completions "$cur"
    }

    complete -F _${name}_completion ${name}
elif type compctl &>/dev/null; then
    _${name}_completion () {
        local cword line point si
        read -Ac words
        read -cn cword
        read -l line
        si="$IFS"
        if ! IFS=$'\n' reply=($(${name} --compzsh --compgen "\${cword}" "\${words[cword - 1]}" \${line})); then
            local ret=$?
            IFS="$si"
            return $ret
        fi
        IFS="$si"
    }

    compctl -K _${name}_completion ${name}
fi`;
};
